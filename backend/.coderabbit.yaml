# CodeRabbit CI configuration for base-app
# This is a recommended pipeline covering linting, unit tests, integration tests, and build.
# Adjust images, Go version, and job resources to match your CodeRabbit environment.

# Triggers: run pipeline on push and pull requests
on:
  push:
    branches:
      - "**"
  pull_request:
    branches:
      - "**"

env:
  BACKEND_DIR: backend
  GO_VERSION: 1.21

jobs:
  lint:
    name: Lint & Format Checks
    image: golang:${GO_VERSION}
    steps:
      - name: Checkout code
        run: git clone ${{ repo.clone_url }} . # CodeRabbit provides repo checkout; replace if necessary

      - name: Run go fmt (check only)
        run: |
          cd ${BACKEND_DIR}
          gofmt_output=$(gofmt -l $(git ls-files '*/**/*.go' | tr '\n' ' ')) || true
          if [ -n "$gofmt_output" ]; then
            echo "Files need formatting (gofmt -w):"
            echo "$gofmt_output"
            exit 2
          fi

      - name: Run go vet
        run: |
          cd ${BACKEND_DIR}
          go vet ./... || true # Not all projects have perfect vetting, don't fail hard by default

  unit_tests:
    name: Unit Tests (Go)
    image: golang:${GO_VERSION}
    steps:
      - name: Checkout code
        run: git clone ${{ repo.clone_url }} .

      - name: Prepare and run unit tests
        run: |
          cd ${BACKEND_DIR}
          go env -w GO111MODULE=on
          go mod download
          make test

  build:
    name: Build backend
    image: golang:${GO_VERSION}
    steps:
      - name: Checkout code
        run: git clone ${{ repo.clone_url }} .

      - name: Build
        run: |
          cd ${BACKEND_DIR}
          go env -w GO111MODULE=on
          go mod download
          make build

      - name: Upload artifact (optional)
        run: |
          # Save built binary. CodeRabbit may have a built-in artifact step.
          ls -al ${BACKEND_DIR}/bin || true

  integration_tests:
    name: Integration Tests (Docker compose + API)
    image: docker:stable
    services:
      - docker:dind
    steps:
      - name: Checkout code
        run: git clone ${{ repo.clone_url }} .

      - name: Start infrastructure
        run: |
          cd ${BACKEND_DIR}
          docker-compose up -d
          echo "Waiting for Postgres/Redis to be healthy..."
          # Poll for endpoint health as a baseline (adapt as needed)
          for i in $(seq 1 30); do
            if docker exec -it base-app-postgres pg_isready -U baseapp &>/dev/null; then
              echo "Postgres is ready"; break
            fi
            echo "Waiting for Postgres... ($i)"; sleep 2
          done

      - name: Run migrations & API tests
        run: |
          cd ${BACKEND_DIR}
          chmod +x scripts/migrate.sh
          ./scripts/migrate.sh up || true
          chmod +x scripts/test-api.sh
          ./scripts/test-api.sh || true

      - name: Tear down
        run: |
          cd ${BACKEND_DIR}
          docker-compose down -v || true

# Notes:
# - This YAML is intended as a good starting point for CodeRabbit. Replace the "git clone" steps with your runner's default checkout step if necessary.
# - Adjust error handling (exit codes) and command flags according to your preferences (e.g., fail fast or allow non-fatal warnings).
# - If you use secrets (DB password, etc.), configure them in CodeRabbit and reference them with the runner's syntax.
# - If your CodeRabbit environment has caching or artifact steps, add them to speed up builds (cache GOPATH/pkg/mod, etc.).
